//! Functions for constructing various containers used in the Ethereum consensus layer.
//!
//! Currently only suitable for use in tests.
//! All containers are signed with keys generated by [`interop::secret_key`].

use core::ops::Range;
use std::sync::Arc;

use anyhow::{bail, Result};
use bls::AggregateSignature;
use deposit_tree::DepositTree;
use helper_functions::{
    accessors, misc,
    signing::{RandaoEpoch, SignForSingleFork as _, SignForSingleForkAtSlot as _},
};
use itertools::Itertools as _;
use ssz::{BitList, BitVector, ContiguousList, SszHash as _};
use std_ext::ArcExt as _;
use transition_functions::{capella, combined};
use try_from_iterator::TryFromIterator as _;
use types::{
    altair::containers::{
        BeaconBlock as AltairBeaconBlock, BeaconBlockBody as AltairBeaconBlockBody, SyncAggregate,
    },
    bellatrix::containers::{
        BeaconBlock as BellatrixBeaconBlock, BeaconBlockBody as BellatrixBeaconBlockBody,
        ExecutionPayload as BellatrixExecutionPayload,
    },
    capella::containers::{
        BeaconBlock as CapellaBeaconBlock, BeaconBlockBody as CapellaBeaconBlockBody,
        ExecutionPayload as CapellaExecutionPayload,
    },
    combined::{BeaconBlock, BeaconState, ExecutionPayload, SignedBeaconBlock},
    config::Config,
    deneb::containers::{
        BeaconBlock as DenebBeaconBlock, BeaconBlockBody as DenebBeaconBlockBody,
        ExecutionPayload as DenebExecutionPayload,
    },
    nonstandard::{AttestationEpoch, Phase, RelativeEpoch},
    phase0::{
        consts::GENESIS_SLOT,
        containers::{
            Attestation, AttestationData, BeaconBlock as Phase0BeaconBlock,
            BeaconBlockBody as Phase0BeaconBlockBody, Checkpoint, Deposit, Eth1Data,
        },
        primitives::{Epoch, ExecutionBlockHash, Slot, SubnetId, ValidatorIndex, H256},
    },
    preset::Preset,
    traits::BeaconState as _,
};

type BlockWithState<P> = (Arc<SignedBeaconBlock<P>>, Arc<BeaconState<P>>);

pub fn min_genesis_state<P: Preset>(config: &Config) -> Result<(Arc<BeaconState<P>>, DepositTree)> {
    let (genesis_state, deposit_tree) = interop::quick_start_beacon_state(
        config,
        config.min_genesis_time,
        config.min_genesis_active_validator_count,
    )?;

    Ok((Arc::new(genesis_state), deposit_tree))
}

pub fn empty_block<P: Preset>(
    config: &Config,
    pre_state: Arc<BeaconState<P>>,
    slot: Slot,
    graffiti: H256,
) -> Result<BlockWithState<P>> {
    let advanced_state = advance_state(config, pre_state, slot)?;
    let eth1_data = advanced_state.eth1_data();
    let attestations = ContiguousList::default();
    let deposits = ContiguousList::default();
    let sync_aggregate = SyncAggregate::empty();
    let execution_payload = None;

    block(
        config,
        advanced_state,
        eth1_data,
        graffiti,
        attestations,
        deposits,
        sync_aggregate,
        execution_payload,
    )
}

pub fn block_justifying_previous_epoch<P: Preset>(
    config: &Config,
    pre_state: Arc<BeaconState<P>>,
    epoch: Epoch,
    graffiti: H256,
) -> Result<BlockWithState<P>> {
    let block_slot = misc::compute_start_slot_at_epoch::<P>(epoch);
    let advanced_state = advance_state(config, pre_state, block_slot)?;
    let eth1_data = advanced_state.eth1_data();
    let attestation_slots = misc::slots_in_epoch::<P>(epoch - 1);
    let attestations = full_aggregate_attestations(config, &advanced_state, attestation_slots)?;
    let deposits = ContiguousList::default();
    let sync_aggregate = SyncAggregate::empty();
    let execution_payload = None;

    block(
        config,
        advanced_state,
        eth1_data,
        graffiti,
        attestations,
        deposits,
        sync_aggregate,
        execution_payload,
    )
}

pub fn block_justifying_current_epoch<P: Preset>(
    config: &Config,
    pre_state: Arc<BeaconState<P>>,
    epoch: Epoch,
    graffiti: H256,
    execution_payload: Option<ExecutionPayload<P>>,
) -> Result<BlockWithState<P>> {
    let block_slot = misc::compute_start_slot_at_epoch::<P>(epoch + 1) - 1;
    let advanced_state = advance_state(config, pre_state, block_slot)?;
    let eth1_data = advanced_state.eth1_data();
    let attestation_slots = misc::compute_start_slot_at_epoch::<P>(epoch)..block_slot;
    let attestations = full_aggregate_attestations(config, &advanced_state, attestation_slots)?;
    let deposits = ContiguousList::default();
    let sync_aggregate = SyncAggregate::empty();

    block(
        config,
        advanced_state,
        eth1_data,
        graffiti,
        attestations,
        deposits,
        sync_aggregate,
        execution_payload,
    )
}

pub fn block_with_deposits<P: Preset>(
    config: &Config,
    pre_state: Arc<BeaconState<P>>,
    slot: Slot,
    deposits: ContiguousList<Deposit, P::MaxDeposits>,
) -> Result<BlockWithState<P>> {
    let advanced_state = advance_state(config, pre_state, slot)?;
    let eth1_data = advanced_state.eth1_data();
    let graffiti = H256::zero();
    let attestations = ContiguousList::default();
    let sync_aggregate = SyncAggregate::empty();
    let execution_payload = None;

    block(
        config,
        advanced_state,
        eth1_data,
        graffiti,
        attestations,
        deposits,
        sync_aggregate,
        execution_payload,
    )
}

pub fn block_with_eth1_vote_and_deposits<P: Preset>(
    config: &Config,
    pre_state: Arc<BeaconState<P>>,
    slot: Slot,
    eth1_vote: Eth1Data,
    deposits: ContiguousList<Deposit, P::MaxDeposits>,
) -> Result<BlockWithState<P>> {
    let advanced_state = advance_state(config, pre_state, slot)?;
    let graffiti = H256::zero();
    let attestations = ContiguousList::default();
    let sync_aggregate = SyncAggregate::empty();
    let execution_payload = None;

    block(
        config,
        advanced_state,
        eth1_vote,
        graffiti,
        attestations,
        deposits,
        sync_aggregate,
        execution_payload,
    )
}

pub fn block_with_payload<P: Preset>(
    config: &Config,
    pre_state: Arc<BeaconState<P>>,
    slot: Slot,
    graffiti: H256,
    execution_payload: ExecutionPayload<P>,
) -> Result<BlockWithState<P>> {
    let advanced_state = advance_state(config, pre_state, slot)?;
    let eth1_data = advanced_state.eth1_data();
    let attestations = ContiguousList::default();
    let deposits = ContiguousList::default();
    let sync_aggregate = SyncAggregate::empty();
    let execution_payload = Some(execution_payload);

    block(
        config,
        advanced_state,
        eth1_data,
        graffiti,
        attestations,
        deposits,
        sync_aggregate,
        execution_payload,
    )
}

pub fn full_blocks_up_to_epoch<P: Preset>(
    config: &Config,
    genesis_state: Arc<BeaconState<P>>,
    end_epoch: Epoch,
) -> Result<Vec<Arc<SignedBeaconBlock<P>>>> {
    let start_slot = GENESIS_SLOT + 1;
    let end_slot = misc::compute_start_slot_at_epoch::<P>(end_epoch);

    let mut pre_state = genesis_state;
    let mut blocks = vec![];

    // This has to be a loop because it moves out of `pre_state`.
    for slot in start_slot..=end_slot {
        let advanced_state = advance_state(config, pre_state, slot)?;
        let eth1_data = advanced_state.eth1_data();
        let graffiti = H256::zero();
        let attestations = full_aggregate_attestations(config, &advanced_state, (slot - 1)..slot)?;
        let deposits = ContiguousList::default();
        let sync_aggregate = full_sync_aggregate(config, &advanced_state);
        let execution_payload = None;

        let (block, post_state) = block(
            config,
            advanced_state,
            eth1_data,
            graffiti,
            attestations,
            deposits,
            sync_aggregate,
            execution_payload,
        )?;

        pre_state = post_state;
        blocks.push(block);
    }

    Ok(blocks)
}

pub fn singular_attestation<P: Preset>(
    config: &Config,
    state: Arc<BeaconState<P>>,
    epoch: Epoch,
    validator_index: ValidatorIndex,
) -> Result<(Attestation<P>, SubnetId)> {
    let start_slot = misc::compute_start_slot_at_epoch::<P>(epoch);
    let state_in_epoch = advance_state(config, state, start_slot)?;

    for slot in misc::slots_in_epoch::<P>(epoch) {
        let committees = accessors::beacon_committees(&state_in_epoch, slot)?;

        for (committee, index) in committees.zip(0..) {
            let committees_per_slot =
                accessors::get_committee_count_per_slot(&state_in_epoch, RelativeEpoch::Current);

            let subnet_id =
                misc::compute_subnet_for_attestation::<P>(committees_per_slot, slot, index)?;

            if let Some(position) = committee
                .into_iter()
                .position(|index| index == validator_index)
            {
                let beacon_block_root = accessors::latest_block_root(&state_in_epoch);
                let root = accessors::epoch_boundary_block_root(&state_in_epoch, beacon_block_root);

                let mut aggregation_bits = BitList::with_length(committee.len());

                aggregation_bits.set(position, true);

                let data = AttestationData {
                    slot,
                    index,
                    beacon_block_root,
                    source: state_in_epoch.current_justified_checkpoint(),
                    target: Checkpoint { epoch, root },
                };

                let secret_key = interop::secret_key(validator_index);

                let attestation = Attestation {
                    aggregation_bits,
                    data,
                    signature: data.sign(config, &state_in_epoch, &secret_key).into(),
                };

                return Ok((attestation, subnet_id));
            }
        }
    }

    bail!("validator should belong to some committee")
}

pub fn execution_payload<P: Preset>(
    config: &Config,
    state: &Arc<BeaconState<P>>,
    slot: Slot,
    block_hash: ExecutionBlockHash,
) -> Result<ExecutionPayload<P>> {
    let parent_hash = state
        .post_bellatrix()
        .map(|state| state.latest_execution_payload_header().block_hash())
        .unwrap_or_default();

    // `accessors::get_current_epoch(state)` is correct even if `slot` is in a later epoch.
    // Using `misc::compute_epoch_at_slot::<P>(slot)` makes the payload invalid unless `state` is
    // advanced to `slot`. See how RANDAO mixes are copied in `process_randao_mixes_reset`.
    let prev_randao = accessors::get_randao_mix(state, accessors::get_current_epoch(state));
    let timestamp = misc::compute_timestamp_at_slot(config, state, slot);

    let withdrawals = state
        .post_capella()
        .map(capella::get_expected_withdrawals)
        .transpose()?
        .unwrap_or_default()
        .try_into()?;

    let execution_payload = match config.phase_at_slot::<P>(slot) {
        Phase::Phase0 | Phase::Altair => bail!("slot should be post-Bellatrix"),
        Phase::Bellatrix => BellatrixExecutionPayload {
            parent_hash,
            prev_randao,
            timestamp,
            block_hash,
            ..BellatrixExecutionPayload::default()
        }
        .into(),
        Phase::Capella => CapellaExecutionPayload {
            parent_hash,
            prev_randao,
            timestamp,
            block_hash,
            withdrawals,
            ..CapellaExecutionPayload::default()
        }
        .into(),
        Phase::Deneb => DenebExecutionPayload {
            parent_hash,
            prev_randao,
            timestamp,
            block_hash,
            ..DenebExecutionPayload::default()
        }
        .into(),
    };

    Ok(execution_payload)
}

#[allow(clippy::too_many_arguments)]
fn block<P: Preset>(
    config: &Config,
    advanced_state: Arc<BeaconState<P>>,
    eth1_data: Eth1Data,
    graffiti: H256,
    attestations: ContiguousList<Attestation<P>, P::MaxAttestations>,
    deposits: ContiguousList<Deposit, P::MaxDeposits>,
    sync_aggregate: SyncAggregate<P>,
    mut execution_payload: Option<ExecutionPayload<P>>,
) -> Result<BlockWithState<P>> {
    let slot = advanced_state.slot();
    let proposer_index = accessors::get_beacon_proposer_index(&advanced_state)?;
    let secret_key = interop::secret_key(proposer_index);
    let parent_root = accessors::latest_block_root(&advanced_state);

    let randao_reveal = RandaoEpoch::from(accessors::get_current_epoch(&advanced_state))
        .sign(config, &advanced_state, &secret_key)
        .into();

    // Starting with `consensus-specs` v1.4.0-alpha.0, all Capella blocks must be post-Merge.
    if advanced_state.phase() >= Phase::Capella && execution_payload.is_none() {
        execution_payload = Some(self::execution_payload(
            config,
            &advanced_state,
            advanced_state.slot(),
            ExecutionBlockHash::zero(),
        )?);
    }

    let without_state_root = match advanced_state.phase() {
        Phase::Phase0 => BeaconBlock::from(Phase0BeaconBlock {
            slot,
            proposer_index,
            parent_root,
            state_root: H256::zero(),
            body: Phase0BeaconBlockBody {
                randao_reveal,
                eth1_data,
                graffiti,
                attestations,
                deposits,
                ..Phase0BeaconBlockBody::default()
            },
        }),
        Phase::Altair => BeaconBlock::from(AltairBeaconBlock {
            slot,
            proposer_index,
            parent_root,
            state_root: H256::zero(),
            body: AltairBeaconBlockBody {
                randao_reveal,
                eth1_data,
                graffiti,
                attestations,
                deposits,
                sync_aggregate,
                ..AltairBeaconBlockBody::default()
            },
        }),
        Phase::Bellatrix => BeaconBlock::from(BellatrixBeaconBlock {
            slot,
            proposer_index,
            parent_root,
            state_root: H256::zero(),
            body: BellatrixBeaconBlockBody {
                randao_reveal,
                eth1_data,
                graffiti,
                attestations,
                deposits,
                sync_aggregate,
                ..BellatrixBeaconBlockBody::default()
            },
        }),
        Phase::Capella => BeaconBlock::from(CapellaBeaconBlock {
            slot,
            proposer_index,
            parent_root,
            state_root: H256::zero(),
            body: CapellaBeaconBlockBody {
                randao_reveal,
                eth1_data,
                graffiti,
                attestations,
                sync_aggregate,
                ..CapellaBeaconBlockBody::default()
            },
        }),
        Phase::Deneb => BeaconBlock::from(DenebBeaconBlock {
            slot,
            proposer_index,
            parent_root,
            state_root: H256::zero(),
            body: DenebBeaconBlockBody {
                randao_reveal,
                eth1_data,
                graffiti,
                attestations,
                sync_aggregate,
                ..DenebBeaconBlockBody::default()
            },
        }),
    }
    .with_execution_payload(execution_payload)?;

    let mut post_state = advanced_state;

    combined::process_untrusted_block(config, post_state.make_mut(), &without_state_root, true)?;

    let message = without_state_root.with_state_root(post_state.hash_tree_root());
    let signature = message.sign(config, &post_state, &secret_key).into();
    let block = Arc::new(message.with_signature(signature));

    Ok((block, post_state))
}

// `advanced_state` is the one for the block being constructed,
// not the one that the attestations would be constructed with.
fn full_aggregate_attestations<P: Preset>(
    config: &Config,
    advanced_state: &BeaconState<P>,
    slots: Range<Slot>,
) -> Result<ContiguousList<Attestation<P>, P::MaxAttestations>> {
    let attestations = slots
        .into_iter()
        .map(|slot| -> Result<_> {
            // `accessors::latest_block_root` would be incorrect in some cases,
            // though we currently don't have any tests that can demonstrate that.
            // `rapid_upgrade_blocks` includes the attestations as early as possible.
            // `fork_choice_control::extra_tests` don't need validators to attest perfectly.
            let beacon_block_root = accessors::get_block_root_at_slot(advanced_state, slot)?;
            let epoch = misc::compute_epoch_at_slot::<P>(slot);
            let attestation_epoch = accessors::attestation_epoch(advanced_state, epoch)?;

            let source = match attestation_epoch {
                AttestationEpoch::Previous => advanced_state.previous_justified_checkpoint(),
                AttestationEpoch::Current => advanced_state.current_justified_checkpoint(),
            };

            let target = Checkpoint {
                epoch,
                // `accessors::epoch_boundary_block_root` would be incorrect because
                // `advanced_state` may be in a different epoch than the attestations.
                root: accessors::get_block_root(advanced_state, attestation_epoch)?,
            };

            let committees = accessors::beacon_committees(advanced_state, slot)?;

            let attestations = committees.zip(0..).map(move |(committee, index)| {
                let data = AttestationData {
                    slot,
                    index,
                    beacon_block_root,
                    source,
                    target,
                };

                let signing_root = data.signing_root(config, advanced_state);

                let signature = committee
                    .into_iter()
                    .map(|validator_index| interop::secret_key(validator_index).sign(signing_root))
                    .reduce(AggregateSignature::aggregate)
                    .unwrap_or_default()
                    .into();

                Attestation {
                    aggregation_bits: BitList::new(true, committee.len()),
                    data,
                    signature,
                }
            });

            Ok(attestations)
        })
        .flatten_ok();

    itertools::process_results(attestations, |attestations| {
        ContiguousList::try_from_iter(attestations)
    })?
    .map_err(Into::into)
}

fn full_sync_aggregate<P: Preset>(
    config: &Config,
    advanced_state: &BeaconState<P>,
) -> SyncAggregate<P> {
    let Some(advanced_state) = advanced_state.post_altair() else {
        return SyncAggregate::empty();
    };

    let parent_root = accessors::latest_block_root(advanced_state);
    let signing_root = parent_root.signing_root(config, advanced_state, advanced_state.slot() - 1);

    let sync_committee_signature = advanced_state
        .current_sync_committee()
        .pubkeys
        .iter()
        .map(|pubkey| {
            accessors::index_of_public_key(advanced_state, pubkey.to_bytes()).expect(
                "public keys in advanced_state.current_sync_committee \
                 are taken from advanced_state.validators",
            )
        })
        .map(|validator_index| interop::secret_key(validator_index).sign(signing_root))
        .reduce(AggregateSignature::aggregate)
        .unwrap_or_default()
        .into();

    SyncAggregate {
        sync_committee_bits: BitVector::new(true),
        sync_committee_signature,
    }
}

fn advance_state<P: Preset>(
    config: &Config,
    mut state: Arc<BeaconState<P>>,
    slot: Slot,
) -> Result<Arc<BeaconState<P>>> {
    if state.slot() < slot {
        combined::process_slots(config, state.make_mut(), slot)?;
    }

    Ok(state)
}
